/*Package contractor(version: "0.1") - Automatically generated by cinp-codegen from /api/v1/Utilities/ at 2020-05-02T23:55:10.746165
 */
package contractor

import (
	"time"
	"reflect"
	cinp "github.com/cinp/go"
)

//UtilitiesNetworked - Model Networked(/api/v1/Utilities/Networked)
/*
Networked(id, hostname, site)
 */
type UtilitiesNetworked struct {
	cinp.BaseObject
	cinp *cinp.CInP
	Hostname string `json:"hostname"`
	Site string `json:"site"`
}

// AsMap returns a map[string]interface{} that is required for create and update
func (object *UtilitiesNetworked) AsMap(isCreate bool) *map[string]interface{} {
	if isCreate {
		return &map[string]interface{}{ 
			"hostname": object.Hostname,
			"site": object.Site,
		}
	}
	return &map[string]interface{}{ 
		"hostname": object.Hostname,
		"site": object.Site,
	}
}

// UtilitiesNetworkedNew - Make a new object of Model Networked
func (service *Contractor) UtilitiesNetworkedNew() *UtilitiesNetworked {
	return &UtilitiesNetworked{cinp: service.cinp}
}

// UtilitiesNetworkedNewWithID - Make a new object of Model Networked
func (service *Contractor) UtilitiesNetworkedNewWithID(id string) *UtilitiesNetworked {
	result := UtilitiesNetworked{cinp: service.cinp}
	result.SetID("/api/v1/Utilities/Networked:"+id+":")
	return &result
}

// UtilitiesNetworkedGet - Get function for Model Networked
func (service *Contractor) UtilitiesNetworkedGet(id string) (*UtilitiesNetworked, error) {
	object, err := service.cinp.Get("/api/v1/Utilities/Networked:"+id+":")
	if err != nil {
		return nil, err
	}
	result := (*object).(*UtilitiesNetworked)
	result.cinp = service.cinp

	return result, nil
}

// Create - Create function for Model Networked
func (object *UtilitiesNetworked) Create() error {
	if err := object.cinp.Create("/api/v1/Utilities/Networked", object); err != nil {
		return err
	}

	return nil
}

// Update - Update function for Model Networked
func (object *UtilitiesNetworked) Update(fieldList []string) error {
	if err := object.cinp.Update(object, fieldList); err != nil {
		return err
	}

	return nil
}

// Delete - Delete function for Model Networked
func (object *UtilitiesNetworked) Delete() error {
	if err := object.cinp.Delete(object); err != nil {
		return err
	}

	return nil
}

// UtilitiesNetworkedList - List function for Model Networked
func (service *Contractor) UtilitiesNetworkedList(filterName string, filterValues map[string]interface{}) <-chan *UtilitiesNetworked {
	in := service.cinp.ListObjects("/api/v1/Utilities/Networked", reflect.TypeOf(UtilitiesNetworked{}), filterName, filterValues, 50)
	out := make(chan *UtilitiesNetworked)
	go func() {
		defer close(out)
		for v := range in {
			v.(*UtilitiesNetworked).cinp = service.cinp
			out <- v.(*UtilitiesNetworked)
		}
	}()
	return out
}


//UtilitiesAddressBlock - Model AddressBlock(/api/v1/Utilities/AddressBlock)
/*
AddressBlock(id, name, site, subnet, prefix, gateway_offset, _max_address, updated, created)
 */
type UtilitiesAddressBlock struct {
	cinp.BaseObject
	cinp *cinp.CInP
	Name string `json:"name"`
	Site string `json:"site"`
	Subnet string `json:"subnet"`
	Prefix int `json:"prefix"`
	GatewayOffset int `json:"gateway_offset"`
	MaxAddress string `json:"_max_address"`
	Updated time.Time `json:"updated"`
	Created time.Time `json:"created"`
	Gateway string `json:"gateway"`
	Netmask string `json:"netmask"`
	Size string `json:"size"`
	Isipv4 string `json:"isIpV4"`
}

// AsMap returns a map[string]interface{} that is required for create and update
func (object *UtilitiesAddressBlock) AsMap(isCreate bool) *map[string]interface{} {
	if isCreate {
		return &map[string]interface{}{ 
			"name": object.Name,
			"site": object.Site,
			"subnet": object.Subnet,
			"prefix": object.Prefix,
			"gateway_offset": object.GatewayOffset,
		}
	}
	return &map[string]interface{}{ 
		"name": object.Name,
		"site": object.Site,
		"subnet": object.Subnet,
		"prefix": object.Prefix,
		"gateway_offset": object.GatewayOffset,
	}
}

// UtilitiesAddressBlockNew - Make a new object of Model AddressBlock
func (service *Contractor) UtilitiesAddressBlockNew() *UtilitiesAddressBlock {
	return &UtilitiesAddressBlock{cinp: service.cinp}
}

// UtilitiesAddressBlockNewWithID - Make a new object of Model AddressBlock
func (service *Contractor) UtilitiesAddressBlockNewWithID(id string) *UtilitiesAddressBlock {
	result := UtilitiesAddressBlock{cinp: service.cinp}
	result.SetID("/api/v1/Utilities/AddressBlock:"+id+":")
	return &result
}

// UtilitiesAddressBlockGet - Get function for Model AddressBlock
func (service *Contractor) UtilitiesAddressBlockGet(id string) (*UtilitiesAddressBlock, error) {
	object, err := service.cinp.Get("/api/v1/Utilities/AddressBlock:"+id+":")
	if err != nil {
		return nil, err
	}
	result := (*object).(*UtilitiesAddressBlock)
	result.cinp = service.cinp

	return result, nil
}

// Create - Create function for Model AddressBlock
func (object *UtilitiesAddressBlock) Create() error {
	if err := object.cinp.Create("/api/v1/Utilities/AddressBlock", object); err != nil {
		return err
	}

	return nil
}

// Update - Update function for Model AddressBlock
func (object *UtilitiesAddressBlock) Update(fieldList []string) error {
	if err := object.cinp.Update(object, fieldList); err != nil {
		return err
	}

	return nil
}

// Delete - Delete function for Model AddressBlock
func (object *UtilitiesAddressBlock) Delete() error {
	if err := object.cinp.Delete(object); err != nil {
		return err
	}

	return nil
}

// UtilitiesAddressBlockList - List function for Model AddressBlock
func (service *Contractor) UtilitiesAddressBlockList(filterName string, filterValues map[string]interface{}) <-chan *UtilitiesAddressBlock {
	in := service.cinp.ListObjects("/api/v1/Utilities/AddressBlock", reflect.TypeOf(UtilitiesAddressBlock{}), filterName, filterValues, 50)
	out := make(chan *UtilitiesAddressBlock)
	go func() {
		defer close(out)
		for v := range in {
			v.(*UtilitiesAddressBlock).cinp = service.cinp
			out <- v.(*UtilitiesAddressBlock)
		}
	}()
	return out
}

// CallNextAddress calls nextAddressNoneNoneNone
func (object *UtilitiesAddressBlock) CallNextAddress(networked string, interface_name string, is_primary bool) (string, error) {
	args := map[string]interface{}{
		"networked": networked,
		"interface_name": interface_name,
		"is_primary": is_primary,
	}
	_, _, _, ids, _, err := object.cinp.Split(object.GetID())
	if err != nil {
		return "", err
	}
	uri, err := object.cinp.UpdateIDs("/api/v1/Utilities/AddressBlock(nextAddress)", ids)
	if err != nil {
		return "", err
	}

	result := ""

	if err := object.cinp.Call(uri, &args, &result); err != nil {
		return "", err
	}

	return result, nil
}

// CallUsage calls usage
func (object *UtilitiesAddressBlock) CallUsage() (map[string]interface{}, error) {
	args := map[string]interface{}{
	}
	_, _, _, ids, _, err := object.cinp.Split(object.GetID())
	if err != nil {
		return nil, err
	}
	uri, err := object.cinp.UpdateIDs("/api/v1/Utilities/AddressBlock(usage)", ids)
	if err != nil {
		return nil, err
	}

	result := map[string]interface{}{}

	if err := object.cinp.Call(uri, &args, &result); err != nil {
		return nil, err
	}

	return result, nil
}


//UtilitiesNetwork - Model Network(/api/v1/Utilities/Network)
/*
Network(id, name, site, updated, created)
 */
type UtilitiesNetwork struct {
	cinp.BaseObject
	cinp *cinp.CInP
	Name string `json:"name"`
	Site string `json:"site"`
	Updated time.Time `json:"updated"`
	Created time.Time `json:"created"`
	AddressBlockList []string `json:"address_block_list"`
}

// AsMap returns a map[string]interface{} that is required for create and update
func (object *UtilitiesNetwork) AsMap(isCreate bool) *map[string]interface{} {
	if isCreate {
		return &map[string]interface{}{ 
			"name": object.Name,
			"site": object.Site,
		}
	}
	return &map[string]interface{}{ 
		"name": object.Name,
		"site": object.Site,
	}
}

// UtilitiesNetworkNew - Make a new object of Model Network
func (service *Contractor) UtilitiesNetworkNew() *UtilitiesNetwork {
	return &UtilitiesNetwork{cinp: service.cinp}
}

// UtilitiesNetworkNewWithID - Make a new object of Model Network
func (service *Contractor) UtilitiesNetworkNewWithID(id string) *UtilitiesNetwork {
	result := UtilitiesNetwork{cinp: service.cinp}
	result.SetID("/api/v1/Utilities/Network:"+id+":")
	return &result
}

// UtilitiesNetworkGet - Get function for Model Network
func (service *Contractor) UtilitiesNetworkGet(id string) (*UtilitiesNetwork, error) {
	object, err := service.cinp.Get("/api/v1/Utilities/Network:"+id+":")
	if err != nil {
		return nil, err
	}
	result := (*object).(*UtilitiesNetwork)
	result.cinp = service.cinp

	return result, nil
}

// Create - Create function for Model Network
func (object *UtilitiesNetwork) Create() error {
	if err := object.cinp.Create("/api/v1/Utilities/Network", object); err != nil {
		return err
	}

	return nil
}

// Update - Update function for Model Network
func (object *UtilitiesNetwork) Update(fieldList []string) error {
	if err := object.cinp.Update(object, fieldList); err != nil {
		return err
	}

	return nil
}

// Delete - Delete function for Model Network
func (object *UtilitiesNetwork) Delete() error {
	if err := object.cinp.Delete(object); err != nil {
		return err
	}

	return nil
}

// UtilitiesNetworkList - List function for Model Network
func (service *Contractor) UtilitiesNetworkList(filterName string, filterValues map[string]interface{}) <-chan *UtilitiesNetwork {
	in := service.cinp.ListObjects("/api/v1/Utilities/Network", reflect.TypeOf(UtilitiesNetwork{}), filterName, filterValues, 50)
	out := make(chan *UtilitiesNetwork)
	go func() {
		defer close(out)
		for v := range in {
			v.(*UtilitiesNetwork).cinp = service.cinp
			out <- v.(*UtilitiesNetwork)
		}
	}()
	return out
}


//UtilitiesNetworkAddressBlock - Model NetworkAddressBlock(/api/v1/Utilities/NetworkAddressBlock)
/*
NetworkAddressBlock(id, network, address_block, vlan, vlan_tagged, updated, created)
 */
type UtilitiesNetworkAddressBlock struct {
	cinp.BaseObject
	cinp *cinp.CInP
	Network string `json:"network"`
	AddressBlock string `json:"address_block"`
	Vlan int `json:"vlan"`
	VlanTagged bool `json:"vlan_tagged"`
	Updated time.Time `json:"updated"`
	Created time.Time `json:"created"`
}

// AsMap returns a map[string]interface{} that is required for create and update
func (object *UtilitiesNetworkAddressBlock) AsMap(isCreate bool) *map[string]interface{} {
	if isCreate {
		return &map[string]interface{}{ 
			"network": object.Network,
			"address_block": object.AddressBlock,
			"vlan": object.Vlan,
			"vlan_tagged": object.VlanTagged,
		}
	}
	return &map[string]interface{}{ 
		"network": object.Network,
		"address_block": object.AddressBlock,
		"vlan": object.Vlan,
		"vlan_tagged": object.VlanTagged,
	}
}

// UtilitiesNetworkAddressBlockNew - Make a new object of Model NetworkAddressBlock
func (service *Contractor) UtilitiesNetworkAddressBlockNew() *UtilitiesNetworkAddressBlock {
	return &UtilitiesNetworkAddressBlock{cinp: service.cinp}
}

// UtilitiesNetworkAddressBlockNewWithID - Make a new object of Model NetworkAddressBlock
func (service *Contractor) UtilitiesNetworkAddressBlockNewWithID(id string) *UtilitiesNetworkAddressBlock {
	result := UtilitiesNetworkAddressBlock{cinp: service.cinp}
	result.SetID("/api/v1/Utilities/NetworkAddressBlock:"+id+":")
	return &result
}

// UtilitiesNetworkAddressBlockGet - Get function for Model NetworkAddressBlock
func (service *Contractor) UtilitiesNetworkAddressBlockGet(id string) (*UtilitiesNetworkAddressBlock, error) {
	object, err := service.cinp.Get("/api/v1/Utilities/NetworkAddressBlock:"+id+":")
	if err != nil {
		return nil, err
	}
	result := (*object).(*UtilitiesNetworkAddressBlock)
	result.cinp = service.cinp

	return result, nil
}

// Create - Create function for Model NetworkAddressBlock
func (object *UtilitiesNetworkAddressBlock) Create() error {
	if err := object.cinp.Create("/api/v1/Utilities/NetworkAddressBlock", object); err != nil {
		return err
	}

	return nil
}

// Update - Update function for Model NetworkAddressBlock
func (object *UtilitiesNetworkAddressBlock) Update(fieldList []string) error {
	if err := object.cinp.Update(object, fieldList); err != nil {
		return err
	}

	return nil
}

// Delete - Delete function for Model NetworkAddressBlock
func (object *UtilitiesNetworkAddressBlock) Delete() error {
	if err := object.cinp.Delete(object); err != nil {
		return err
	}

	return nil
}

// UtilitiesNetworkAddressBlockList - List function for Model NetworkAddressBlock
func (service *Contractor) UtilitiesNetworkAddressBlockList(filterName string, filterValues map[string]interface{}) <-chan *UtilitiesNetworkAddressBlock {
	in := service.cinp.ListObjects("/api/v1/Utilities/NetworkAddressBlock", reflect.TypeOf(UtilitiesNetworkAddressBlock{}), filterName, filterValues, 50)
	out := make(chan *UtilitiesNetworkAddressBlock)
	go func() {
		defer close(out)
		for v := range in {
			v.(*UtilitiesNetworkAddressBlock).cinp = service.cinp
			out <- v.(*UtilitiesNetworkAddressBlock)
		}
	}()
	return out
}


//UtilitiesNetworkInterface - Model NetworkInterface(/api/v1/Utilities/NetworkInterface)
/*
NetworkInterface(id, name, is_provisioning, network, updated, created)
 */
type UtilitiesNetworkInterface struct {
	cinp.BaseObject
	cinp *cinp.CInP
	Name string `json:"name"`
	IsProvisioning bool `json:"is_provisioning"`
	Network string `json:"network"`
	Updated time.Time `json:"updated"`
	Created time.Time `json:"created"`
}

// AsMap returns a map[string]interface{} that is required for create and update
func (object *UtilitiesNetworkInterface) AsMap(isCreate bool) *map[string]interface{} {
	if isCreate {
		return &map[string]interface{}{ 
			"name": object.Name,
			"is_provisioning": object.IsProvisioning,
			"network": object.Network,
		}
	}
	return &map[string]interface{}{ 
		"name": object.Name,
		"is_provisioning": object.IsProvisioning,
		"network": object.Network,
	}
}

// UtilitiesNetworkInterfaceNew - Make a new object of Model NetworkInterface
func (service *Contractor) UtilitiesNetworkInterfaceNew() *UtilitiesNetworkInterface {
	return &UtilitiesNetworkInterface{cinp: service.cinp}
}

// UtilitiesNetworkInterfaceNewWithID - Make a new object of Model NetworkInterface
func (service *Contractor) UtilitiesNetworkInterfaceNewWithID(id string) *UtilitiesNetworkInterface {
	result := UtilitiesNetworkInterface{cinp: service.cinp}
	result.SetID("/api/v1/Utilities/NetworkInterface:"+id+":")
	return &result
}

// UtilitiesNetworkInterfaceGet - Get function for Model NetworkInterface
func (service *Contractor) UtilitiesNetworkInterfaceGet(id string) (*UtilitiesNetworkInterface, error) {
	object, err := service.cinp.Get("/api/v1/Utilities/NetworkInterface:"+id+":")
	if err != nil {
		return nil, err
	}
	result := (*object).(*UtilitiesNetworkInterface)
	result.cinp = service.cinp

	return result, nil
}

// Create - Create function for Model NetworkInterface
func (object *UtilitiesNetworkInterface) Create() error {
	if err := object.cinp.Create("/api/v1/Utilities/NetworkInterface", object); err != nil {
		return err
	}

	return nil
}

// Update - Update function for Model NetworkInterface
func (object *UtilitiesNetworkInterface) Update(fieldList []string) error {
	if err := object.cinp.Update(object, fieldList); err != nil {
		return err
	}

	return nil
}

// Delete - Delete function for Model NetworkInterface
func (object *UtilitiesNetworkInterface) Delete() error {
	if err := object.cinp.Delete(object); err != nil {
		return err
	}

	return nil
}

// UtilitiesNetworkInterfaceList - List function for Model NetworkInterface
func (service *Contractor) UtilitiesNetworkInterfaceList(filterName string, filterValues map[string]interface{}) <-chan *UtilitiesNetworkInterface {
	in := service.cinp.ListObjects("/api/v1/Utilities/NetworkInterface", reflect.TypeOf(UtilitiesNetworkInterface{}), filterName, filterValues, 50)
	out := make(chan *UtilitiesNetworkInterface)
	go func() {
		defer close(out)
		for v := range in {
			v.(*UtilitiesNetworkInterface).cinp = service.cinp
			out <- v.(*UtilitiesNetworkInterface)
		}
	}()
	return out
}


//UtilitiesRealNetworkInterface - Model RealNetworkInterface(/api/v1/Utilities/RealNetworkInterface)
/*
RealNetworkInterface(id, name, is_provisioning, network, updated, created, networkinterface_ptr, mac, foundation, physical_location, link_name, pxe)
 */
type UtilitiesRealNetworkInterface struct {
	cinp.BaseObject
	cinp *cinp.CInP
	Name string `json:"name"`
	IsProvisioning bool `json:"is_provisioning"`
	Network string `json:"network"`
	Updated time.Time `json:"updated"`
	Created time.Time `json:"created"`
	Mac string `json:"mac"`
	Foundation string `json:"foundation"`
	PhysicalLocation string `json:"physical_location"`
	LinkName string `json:"link_name"`
	Pxe string `json:"pxe"`
}

// AsMap returns a map[string]interface{} that is required for create and update
func (object *UtilitiesRealNetworkInterface) AsMap(isCreate bool) *map[string]interface{} {
	if isCreate {
		return &map[string]interface{}{ 
			"name": object.Name,
			"is_provisioning": object.IsProvisioning,
			"network": object.Network,
			"mac": object.Mac,
			"foundation": object.Foundation,
			"physical_location": object.PhysicalLocation,
			"link_name": object.LinkName,
			"pxe": object.Pxe,
		}
	}
	return &map[string]interface{}{ 
		"name": object.Name,
		"is_provisioning": object.IsProvisioning,
		"network": object.Network,
		"mac": object.Mac,
		"foundation": object.Foundation,
		"physical_location": object.PhysicalLocation,
		"link_name": object.LinkName,
		"pxe": object.Pxe,
	}
}

// UtilitiesRealNetworkInterfaceNew - Make a new object of Model RealNetworkInterface
func (service *Contractor) UtilitiesRealNetworkInterfaceNew() *UtilitiesRealNetworkInterface {
	return &UtilitiesRealNetworkInterface{cinp: service.cinp}
}

// UtilitiesRealNetworkInterfaceNewWithID - Make a new object of Model RealNetworkInterface
func (service *Contractor) UtilitiesRealNetworkInterfaceNewWithID(id string) *UtilitiesRealNetworkInterface {
	result := UtilitiesRealNetworkInterface{cinp: service.cinp}
	result.SetID("/api/v1/Utilities/RealNetworkInterface:"+id+":")
	return &result
}

// UtilitiesRealNetworkInterfaceGet - Get function for Model RealNetworkInterface
func (service *Contractor) UtilitiesRealNetworkInterfaceGet(id string) (*UtilitiesRealNetworkInterface, error) {
	object, err := service.cinp.Get("/api/v1/Utilities/RealNetworkInterface:"+id+":")
	if err != nil {
		return nil, err
	}
	result := (*object).(*UtilitiesRealNetworkInterface)
	result.cinp = service.cinp

	return result, nil
}

// Create - Create function for Model RealNetworkInterface
func (object *UtilitiesRealNetworkInterface) Create() error {
	if err := object.cinp.Create("/api/v1/Utilities/RealNetworkInterface", object); err != nil {
		return err
	}

	return nil
}

// Update - Update function for Model RealNetworkInterface
func (object *UtilitiesRealNetworkInterface) Update(fieldList []string) error {
	if err := object.cinp.Update(object, fieldList); err != nil {
		return err
	}

	return nil
}

// Delete - Delete function for Model RealNetworkInterface
func (object *UtilitiesRealNetworkInterface) Delete() error {
	if err := object.cinp.Delete(object); err != nil {
		return err
	}

	return nil
}

// UtilitiesRealNetworkInterfaceList - List function for Model RealNetworkInterface
func (service *Contractor) UtilitiesRealNetworkInterfaceList(filterName string, filterValues map[string]interface{}) <-chan *UtilitiesRealNetworkInterface {
	in := service.cinp.ListObjects("/api/v1/Utilities/RealNetworkInterface", reflect.TypeOf(UtilitiesRealNetworkInterface{}), filterName, filterValues, 50)
	out := make(chan *UtilitiesRealNetworkInterface)
	go func() {
		defer close(out)
		for v := range in {
			v.(*UtilitiesRealNetworkInterface).cinp = service.cinp
			out <- v.(*UtilitiesRealNetworkInterface)
		}
	}()
	return out
}


//UtilitiesAbstractNetworkInterface - Model AbstractNetworkInterface(/api/v1/Utilities/AbstractNetworkInterface)
/*
AbstractNetworkInterface(id, name, is_provisioning, network, updated, created, networkinterface_ptr)
 */
type UtilitiesAbstractNetworkInterface struct {
	cinp.BaseObject
	cinp *cinp.CInP
	Name string `json:"name"`
	IsProvisioning bool `json:"is_provisioning"`
	Network string `json:"network"`
	Updated time.Time `json:"updated"`
	Created time.Time `json:"created"`
}

// AsMap returns a map[string]interface{} that is required for create and update
func (object *UtilitiesAbstractNetworkInterface) AsMap(isCreate bool) *map[string]interface{} {
	if isCreate {
		return &map[string]interface{}{ 
			"name": object.Name,
			"is_provisioning": object.IsProvisioning,
			"network": object.Network,
		}
	}
	return &map[string]interface{}{ 
		"name": object.Name,
		"is_provisioning": object.IsProvisioning,
		"network": object.Network,
	}
}

// UtilitiesAbstractNetworkInterfaceNew - Make a new object of Model AbstractNetworkInterface
func (service *Contractor) UtilitiesAbstractNetworkInterfaceNew() *UtilitiesAbstractNetworkInterface {
	return &UtilitiesAbstractNetworkInterface{cinp: service.cinp}
}

// UtilitiesAbstractNetworkInterfaceNewWithID - Make a new object of Model AbstractNetworkInterface
func (service *Contractor) UtilitiesAbstractNetworkInterfaceNewWithID(id string) *UtilitiesAbstractNetworkInterface {
	result := UtilitiesAbstractNetworkInterface{cinp: service.cinp}
	result.SetID("/api/v1/Utilities/AbstractNetworkInterface:"+id+":")
	return &result
}

// UtilitiesAbstractNetworkInterfaceGet - Get function for Model AbstractNetworkInterface
func (service *Contractor) UtilitiesAbstractNetworkInterfaceGet(id string) (*UtilitiesAbstractNetworkInterface, error) {
	object, err := service.cinp.Get("/api/v1/Utilities/AbstractNetworkInterface:"+id+":")
	if err != nil {
		return nil, err
	}
	result := (*object).(*UtilitiesAbstractNetworkInterface)
	result.cinp = service.cinp

	return result, nil
}

// Create - Create function for Model AbstractNetworkInterface
func (object *UtilitiesAbstractNetworkInterface) Create() error {
	if err := object.cinp.Create("/api/v1/Utilities/AbstractNetworkInterface", object); err != nil {
		return err
	}

	return nil
}

// Update - Update function for Model AbstractNetworkInterface
func (object *UtilitiesAbstractNetworkInterface) Update(fieldList []string) error {
	if err := object.cinp.Update(object, fieldList); err != nil {
		return err
	}

	return nil
}

// Delete - Delete function for Model AbstractNetworkInterface
func (object *UtilitiesAbstractNetworkInterface) Delete() error {
	if err := object.cinp.Delete(object); err != nil {
		return err
	}

	return nil
}

// UtilitiesAbstractNetworkInterfaceList - List function for Model AbstractNetworkInterface
func (service *Contractor) UtilitiesAbstractNetworkInterfaceList(filterName string, filterValues map[string]interface{}) <-chan *UtilitiesAbstractNetworkInterface {
	in := service.cinp.ListObjects("/api/v1/Utilities/AbstractNetworkInterface", reflect.TypeOf(UtilitiesAbstractNetworkInterface{}), filterName, filterValues, 50)
	out := make(chan *UtilitiesAbstractNetworkInterface)
	go func() {
		defer close(out)
		for v := range in {
			v.(*UtilitiesAbstractNetworkInterface).cinp = service.cinp
			out <- v.(*UtilitiesAbstractNetworkInterface)
		}
	}()
	return out
}


//UtilitiesAggregatedNetworkInterface - Model AggregatedNetworkInterface(/api/v1/Utilities/AggregatedNetworkInterface)
/*
AggregatedNetworkInterface(id, name, is_provisioning, network, updated, created, networkinterface_ptr, abstractnetworkinterface_ptr, master_interface, paramaters)
 */
type UtilitiesAggregatedNetworkInterface struct {
	cinp.BaseObject
	cinp *cinp.CInP
	Name string `json:"name"`
	IsProvisioning bool `json:"is_provisioning"`
	Network string `json:"network"`
	Updated time.Time `json:"updated"`
	Created time.Time `json:"created"`
	MasterInterface string `json:"master_interface"`
	Paramaters map[string]interface{} `json:"paramaters"`
	Slaves []string `json:"slaves"`
}

// AsMap returns a map[string]interface{} that is required for create and update
func (object *UtilitiesAggregatedNetworkInterface) AsMap(isCreate bool) *map[string]interface{} {
	if isCreate {
		return &map[string]interface{}{ 
			"name": object.Name,
			"is_provisioning": object.IsProvisioning,
			"network": object.Network,
			"master_interface": object.MasterInterface,
			"paramaters": object.Paramaters,
			"slaves": object.Slaves,
		}
	}
	return &map[string]interface{}{ 
		"name": object.Name,
		"is_provisioning": object.IsProvisioning,
		"network": object.Network,
		"master_interface": object.MasterInterface,
		"paramaters": object.Paramaters,
		"slaves": object.Slaves,
	}
}

// UtilitiesAggregatedNetworkInterfaceNew - Make a new object of Model AggregatedNetworkInterface
func (service *Contractor) UtilitiesAggregatedNetworkInterfaceNew() *UtilitiesAggregatedNetworkInterface {
	return &UtilitiesAggregatedNetworkInterface{cinp: service.cinp}
}

// UtilitiesAggregatedNetworkInterfaceNewWithID - Make a new object of Model AggregatedNetworkInterface
func (service *Contractor) UtilitiesAggregatedNetworkInterfaceNewWithID(id string) *UtilitiesAggregatedNetworkInterface {
	result := UtilitiesAggregatedNetworkInterface{cinp: service.cinp}
	result.SetID("/api/v1/Utilities/AggregatedNetworkInterface:"+id+":")
	return &result
}

// UtilitiesAggregatedNetworkInterfaceGet - Get function for Model AggregatedNetworkInterface
func (service *Contractor) UtilitiesAggregatedNetworkInterfaceGet(id string) (*UtilitiesAggregatedNetworkInterface, error) {
	object, err := service.cinp.Get("/api/v1/Utilities/AggregatedNetworkInterface:"+id+":")
	if err != nil {
		return nil, err
	}
	result := (*object).(*UtilitiesAggregatedNetworkInterface)
	result.cinp = service.cinp

	return result, nil
}

// Create - Create function for Model AggregatedNetworkInterface
func (object *UtilitiesAggregatedNetworkInterface) Create() error {
	if err := object.cinp.Create("/api/v1/Utilities/AggregatedNetworkInterface", object); err != nil {
		return err
	}

	return nil
}

// Update - Update function for Model AggregatedNetworkInterface
func (object *UtilitiesAggregatedNetworkInterface) Update(fieldList []string) error {
	if err := object.cinp.Update(object, fieldList); err != nil {
		return err
	}

	return nil
}

// Delete - Delete function for Model AggregatedNetworkInterface
func (object *UtilitiesAggregatedNetworkInterface) Delete() error {
	if err := object.cinp.Delete(object); err != nil {
		return err
	}

	return nil
}

// UtilitiesAggregatedNetworkInterfaceList - List function for Model AggregatedNetworkInterface
func (service *Contractor) UtilitiesAggregatedNetworkInterfaceList(filterName string, filterValues map[string]interface{}) <-chan *UtilitiesAggregatedNetworkInterface {
	in := service.cinp.ListObjects("/api/v1/Utilities/AggregatedNetworkInterface", reflect.TypeOf(UtilitiesAggregatedNetworkInterface{}), filterName, filterValues, 50)
	out := make(chan *UtilitiesAggregatedNetworkInterface)
	go func() {
		defer close(out)
		for v := range in {
			v.(*UtilitiesAggregatedNetworkInterface).cinp = service.cinp
			out <- v.(*UtilitiesAggregatedNetworkInterface)
		}
	}()
	return out
}


//UtilitiesBaseAddress - Model BaseAddress(/api/v1/Utilities/BaseAddress)
/*
BaseAddress(id, address_block, offset, updated, created)
 */
type UtilitiesBaseAddress struct {
	cinp.BaseObject
	cinp *cinp.CInP
	AddressBlock string `json:"address_block"`
	Offset int `json:"offset"`
	Updated time.Time `json:"updated"`
	Created time.Time `json:"created"`
	Type string `json:"type"`
	IPAddress string `json:"ip_address"`
	Subnet string `json:"subnet"`
	Netmask string `json:"netmask"`
	Prefix string `json:"prefix"`
	Gateway string `json:"gateway"`
}

// AsMap returns a map[string]interface{} that is required for create and update
func (object *UtilitiesBaseAddress) AsMap(isCreate bool) *map[string]interface{} {
	if isCreate {
		return &map[string]interface{}{ 
			"address_block": object.AddressBlock,
			"offset": object.Offset,
		}
	}
	return &map[string]interface{}{ 
		"address_block": object.AddressBlock,
		"offset": object.Offset,
	}
}

// UtilitiesBaseAddressNew - Make a new object of Model BaseAddress
func (service *Contractor) UtilitiesBaseAddressNew() *UtilitiesBaseAddress {
	return &UtilitiesBaseAddress{cinp: service.cinp}
}

// UtilitiesBaseAddressNewWithID - Make a new object of Model BaseAddress
func (service *Contractor) UtilitiesBaseAddressNewWithID(id string) *UtilitiesBaseAddress {
	result := UtilitiesBaseAddress{cinp: service.cinp}
	result.SetID("/api/v1/Utilities/BaseAddress:"+id+":")
	return &result
}

// UtilitiesBaseAddressGet - Get function for Model BaseAddress
func (service *Contractor) UtilitiesBaseAddressGet(id string) (*UtilitiesBaseAddress, error) {
	object, err := service.cinp.Get("/api/v1/Utilities/BaseAddress:"+id+":")
	if err != nil {
		return nil, err
	}
	result := (*object).(*UtilitiesBaseAddress)
	result.cinp = service.cinp

	return result, nil
}

// Create - Create function for Model BaseAddress
func (object *UtilitiesBaseAddress) Create() error {
	if err := object.cinp.Create("/api/v1/Utilities/BaseAddress", object); err != nil {
		return err
	}

	return nil
}

// Update - Update function for Model BaseAddress
func (object *UtilitiesBaseAddress) Update(fieldList []string) error {
	if err := object.cinp.Update(object, fieldList); err != nil {
		return err
	}

	return nil
}

// Delete - Delete function for Model BaseAddress
func (object *UtilitiesBaseAddress) Delete() error {
	if err := object.cinp.Delete(object); err != nil {
		return err
	}

	return nil
}

// UtilitiesBaseAddressList - List function for Model BaseAddress
func (service *Contractor) UtilitiesBaseAddressList(filterName string, filterValues map[string]interface{}) <-chan *UtilitiesBaseAddress {
	in := service.cinp.ListObjects("/api/v1/Utilities/BaseAddress", reflect.TypeOf(UtilitiesBaseAddress{}), filterName, filterValues, 50)
	out := make(chan *UtilitiesBaseAddress)
	go func() {
		defer close(out)
		for v := range in {
			v.(*UtilitiesBaseAddress).cinp = service.cinp
			out <- v.(*UtilitiesBaseAddress)
		}
	}()
	return out
}

// UtilitiesBaseAddressCallLookup calls lookupNone
func (service *Contractor) UtilitiesBaseAddressCallLookup(ip_address string) (string, error) {
	args := map[string]interface{}{
		"ip_address": ip_address,
	}
	uri := "/api/v1/Utilities/BaseAddress(lookup)"

	result := ""

	if err := service.cinp.Call(uri, &args, &result); err != nil {
		return "", err
	}

	return result, nil
}


//UtilitiesAddress - Model Address(/api/v1/Utilities/Address)
/*
Address(id, address_block, offset, updated, created, baseaddress_ptr, networked, interface_name, sub_interface, pointer, is_primary)
 */
type UtilitiesAddress struct {
	cinp.BaseObject
	cinp *cinp.CInP
	AddressBlock string `json:"address_block"`
	Offset int `json:"offset"`
	Updated time.Time `json:"updated"`
	Created time.Time `json:"created"`
	Networked string `json:"networked"`
	InterfaceName string `json:"interface_name"`
	SubInterface int `json:"sub_interface"`
	Pointer string `json:"pointer"`
	IsPrimary bool `json:"is_primary"`
	Type string `json:"type"`
	IPAddress string `json:"ip_address"`
	Subnet string `json:"subnet"`
	Netmask string `json:"netmask"`
	Prefix string `json:"prefix"`
	Gateway string `json:"gateway"`
}

// AsMap returns a map[string]interface{} that is required for create and update
func (object *UtilitiesAddress) AsMap(isCreate bool) *map[string]interface{} {
	if isCreate {
		return &map[string]interface{}{ 
			"address_block": object.AddressBlock,
			"offset": object.Offset,
			"networked": object.Networked,
			"interface_name": object.InterfaceName,
			"sub_interface": object.SubInterface,
			"pointer": object.Pointer,
			"is_primary": object.IsPrimary,
		}
	}
	return &map[string]interface{}{ 
		"address_block": object.AddressBlock,
		"offset": object.Offset,
		"networked": object.Networked,
		"interface_name": object.InterfaceName,
		"sub_interface": object.SubInterface,
		"pointer": object.Pointer,
		"is_primary": object.IsPrimary,
	}
}

// UtilitiesAddressNew - Make a new object of Model Address
func (service *Contractor) UtilitiesAddressNew() *UtilitiesAddress {
	return &UtilitiesAddress{cinp: service.cinp}
}

// UtilitiesAddressNewWithID - Make a new object of Model Address
func (service *Contractor) UtilitiesAddressNewWithID(id string) *UtilitiesAddress {
	result := UtilitiesAddress{cinp: service.cinp}
	result.SetID("/api/v1/Utilities/Address:"+id+":")
	return &result
}

// UtilitiesAddressGet - Get function for Model Address
func (service *Contractor) UtilitiesAddressGet(id string) (*UtilitiesAddress, error) {
	object, err := service.cinp.Get("/api/v1/Utilities/Address:"+id+":")
	if err != nil {
		return nil, err
	}
	result := (*object).(*UtilitiesAddress)
	result.cinp = service.cinp

	return result, nil
}

// Create - Create function for Model Address
func (object *UtilitiesAddress) Create() error {
	if err := object.cinp.Create("/api/v1/Utilities/Address", object); err != nil {
		return err
	}

	return nil
}

// Update - Update function for Model Address
func (object *UtilitiesAddress) Update(fieldList []string) error {
	if err := object.cinp.Update(object, fieldList); err != nil {
		return err
	}

	return nil
}

// Delete - Delete function for Model Address
func (object *UtilitiesAddress) Delete() error {
	if err := object.cinp.Delete(object); err != nil {
		return err
	}

	return nil
}

// UtilitiesAddressList - List function for Model Address
func (service *Contractor) UtilitiesAddressList(filterName string, filterValues map[string]interface{}) <-chan *UtilitiesAddress {
	in := service.cinp.ListObjects("/api/v1/Utilities/Address", reflect.TypeOf(UtilitiesAddress{}), filterName, filterValues, 50)
	out := make(chan *UtilitiesAddress)
	go func() {
		defer close(out)
		for v := range in {
			v.(*UtilitiesAddress).cinp = service.cinp
			out <- v.(*UtilitiesAddress)
		}
	}()
	return out
}


//UtilitiesReservedAddress - Model ReservedAddress(/api/v1/Utilities/ReservedAddress)
/*
ReservedAddress(id, address_block, offset, updated, created, baseaddress_ptr, reason)
 */
type UtilitiesReservedAddress struct {
	cinp.BaseObject
	cinp *cinp.CInP
	AddressBlock string `json:"address_block"`
	Offset int `json:"offset"`
	Updated time.Time `json:"updated"`
	Created time.Time `json:"created"`
	Reason string `json:"reason"`
	Type string `json:"type"`
	IPAddress string `json:"ip_address"`
	Subnet string `json:"subnet"`
	Netmask string `json:"netmask"`
	Prefix string `json:"prefix"`
	Gateway string `json:"gateway"`
}

// AsMap returns a map[string]interface{} that is required for create and update
func (object *UtilitiesReservedAddress) AsMap(isCreate bool) *map[string]interface{} {
	if isCreate {
		return &map[string]interface{}{ 
			"address_block": object.AddressBlock,
			"offset": object.Offset,
			"reason": object.Reason,
		}
	}
	return &map[string]interface{}{ 
		"address_block": object.AddressBlock,
		"offset": object.Offset,
		"reason": object.Reason,
	}
}

// UtilitiesReservedAddressNew - Make a new object of Model ReservedAddress
func (service *Contractor) UtilitiesReservedAddressNew() *UtilitiesReservedAddress {
	return &UtilitiesReservedAddress{cinp: service.cinp}
}

// UtilitiesReservedAddressNewWithID - Make a new object of Model ReservedAddress
func (service *Contractor) UtilitiesReservedAddressNewWithID(id string) *UtilitiesReservedAddress {
	result := UtilitiesReservedAddress{cinp: service.cinp}
	result.SetID("/api/v1/Utilities/ReservedAddress:"+id+":")
	return &result
}

// UtilitiesReservedAddressGet - Get function for Model ReservedAddress
func (service *Contractor) UtilitiesReservedAddressGet(id string) (*UtilitiesReservedAddress, error) {
	object, err := service.cinp.Get("/api/v1/Utilities/ReservedAddress:"+id+":")
	if err != nil {
		return nil, err
	}
	result := (*object).(*UtilitiesReservedAddress)
	result.cinp = service.cinp

	return result, nil
}

// Create - Create function for Model ReservedAddress
func (object *UtilitiesReservedAddress) Create() error {
	if err := object.cinp.Create("/api/v1/Utilities/ReservedAddress", object); err != nil {
		return err
	}

	return nil
}

// Update - Update function for Model ReservedAddress
func (object *UtilitiesReservedAddress) Update(fieldList []string) error {
	if err := object.cinp.Update(object, fieldList); err != nil {
		return err
	}

	return nil
}

// Delete - Delete function for Model ReservedAddress
func (object *UtilitiesReservedAddress) Delete() error {
	if err := object.cinp.Delete(object); err != nil {
		return err
	}

	return nil
}

// UtilitiesReservedAddressList - List function for Model ReservedAddress
func (service *Contractor) UtilitiesReservedAddressList(filterName string, filterValues map[string]interface{}) <-chan *UtilitiesReservedAddress {
	in := service.cinp.ListObjects("/api/v1/Utilities/ReservedAddress", reflect.TypeOf(UtilitiesReservedAddress{}), filterName, filterValues, 50)
	out := make(chan *UtilitiesReservedAddress)
	go func() {
		defer close(out)
		for v := range in {
			v.(*UtilitiesReservedAddress).cinp = service.cinp
			out <- v.(*UtilitiesReservedAddress)
		}
	}()
	return out
}


//UtilitiesDynamicAddress - Model DynamicAddress(/api/v1/Utilities/DynamicAddress)
/*
DynamicAddress(id, address_block, offset, updated, created, baseaddress_ptr, pxe)
 */
type UtilitiesDynamicAddress struct {
	cinp.BaseObject
	cinp *cinp.CInP
	AddressBlock string `json:"address_block"`
	Offset int `json:"offset"`
	Updated time.Time `json:"updated"`
	Created time.Time `json:"created"`
	Pxe string `json:"pxe"`
	Type string `json:"type"`
	IPAddress string `json:"ip_address"`
	Subnet string `json:"subnet"`
	Netmask string `json:"netmask"`
	Prefix string `json:"prefix"`
	Gateway string `json:"gateway"`
}

// AsMap returns a map[string]interface{} that is required for create and update
func (object *UtilitiesDynamicAddress) AsMap(isCreate bool) *map[string]interface{} {
	if isCreate {
		return &map[string]interface{}{ 
			"address_block": object.AddressBlock,
			"offset": object.Offset,
			"pxe": object.Pxe,
		}
	}
	return &map[string]interface{}{ 
		"address_block": object.AddressBlock,
		"offset": object.Offset,
		"pxe": object.Pxe,
	}
}

// UtilitiesDynamicAddressNew - Make a new object of Model DynamicAddress
func (service *Contractor) UtilitiesDynamicAddressNew() *UtilitiesDynamicAddress {
	return &UtilitiesDynamicAddress{cinp: service.cinp}
}

// UtilitiesDynamicAddressNewWithID - Make a new object of Model DynamicAddress
func (service *Contractor) UtilitiesDynamicAddressNewWithID(id string) *UtilitiesDynamicAddress {
	result := UtilitiesDynamicAddress{cinp: service.cinp}
	result.SetID("/api/v1/Utilities/DynamicAddress:"+id+":")
	return &result
}

// UtilitiesDynamicAddressGet - Get function for Model DynamicAddress
func (service *Contractor) UtilitiesDynamicAddressGet(id string) (*UtilitiesDynamicAddress, error) {
	object, err := service.cinp.Get("/api/v1/Utilities/DynamicAddress:"+id+":")
	if err != nil {
		return nil, err
	}
	result := (*object).(*UtilitiesDynamicAddress)
	result.cinp = service.cinp

	return result, nil
}

// Create - Create function for Model DynamicAddress
func (object *UtilitiesDynamicAddress) Create() error {
	if err := object.cinp.Create("/api/v1/Utilities/DynamicAddress", object); err != nil {
		return err
	}

	return nil
}

// Update - Update function for Model DynamicAddress
func (object *UtilitiesDynamicAddress) Update(fieldList []string) error {
	if err := object.cinp.Update(object, fieldList); err != nil {
		return err
	}

	return nil
}

// Delete - Delete function for Model DynamicAddress
func (object *UtilitiesDynamicAddress) Delete() error {
	if err := object.cinp.Delete(object); err != nil {
		return err
	}

	return nil
}

// UtilitiesDynamicAddressList - List function for Model DynamicAddress
func (service *Contractor) UtilitiesDynamicAddressList(filterName string, filterValues map[string]interface{}) <-chan *UtilitiesDynamicAddress {
	in := service.cinp.ListObjects("/api/v1/Utilities/DynamicAddress", reflect.TypeOf(UtilitiesDynamicAddress{}), filterName, filterValues, 50)
	out := make(chan *UtilitiesDynamicAddress)
	go func() {
		defer close(out)
		for v := range in {
			v.(*UtilitiesDynamicAddress).cinp = service.cinp
			out <- v.(*UtilitiesDynamicAddress)
		}
	}()
	return out
}

func registerUtilities(cinp *cinp.CInP) { 
	cinp.RegisterType("/api/v1/Utilities/Networked", reflect.TypeOf((*UtilitiesNetworked)(nil)).Elem())
	cinp.RegisterType("/api/v1/Utilities/AddressBlock", reflect.TypeOf((*UtilitiesAddressBlock)(nil)).Elem())
	cinp.RegisterType("/api/v1/Utilities/Network", reflect.TypeOf((*UtilitiesNetwork)(nil)).Elem())
	cinp.RegisterType("/api/v1/Utilities/NetworkAddressBlock", reflect.TypeOf((*UtilitiesNetworkAddressBlock)(nil)).Elem())
	cinp.RegisterType("/api/v1/Utilities/NetworkInterface", reflect.TypeOf((*UtilitiesNetworkInterface)(nil)).Elem())
	cinp.RegisterType("/api/v1/Utilities/RealNetworkInterface", reflect.TypeOf((*UtilitiesRealNetworkInterface)(nil)).Elem())
	cinp.RegisterType("/api/v1/Utilities/AbstractNetworkInterface", reflect.TypeOf((*UtilitiesAbstractNetworkInterface)(nil)).Elem())
	cinp.RegisterType("/api/v1/Utilities/AggregatedNetworkInterface", reflect.TypeOf((*UtilitiesAggregatedNetworkInterface)(nil)).Elem())
	cinp.RegisterType("/api/v1/Utilities/BaseAddress", reflect.TypeOf((*UtilitiesBaseAddress)(nil)).Elem())
	cinp.RegisterType("/api/v1/Utilities/Address", reflect.TypeOf((*UtilitiesAddress)(nil)).Elem())
	cinp.RegisterType("/api/v1/Utilities/ReservedAddress", reflect.TypeOf((*UtilitiesReservedAddress)(nil)).Elem())
	cinp.RegisterType("/api/v1/Utilities/DynamicAddress", reflect.TypeOf((*UtilitiesDynamicAddress)(nil)).Elem())
}