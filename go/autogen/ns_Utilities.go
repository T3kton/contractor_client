// Package contractor - (version: "0.1") - Automatically generated by cinp-codegen from /api/v1/Utilities/ at 2024-03-26T14:17:37.955685
package contractor

import (
	"fmt"
	cinp "github.com/cinp/go"
	"reflect"
	"strconv"
	"time"
)

// UtilitiesNetworked - Model Networked(/api/v1/Utilities/Networked)
/*
Networked(id, hostname, site)
*/
type UtilitiesNetworked struct {
	cinp.BaseObject
	cinp     *cinp.CInP
	Hostname *string `json:"hostname"`
	Site     *string `json:"site"`
	ID       *int    `json:"id"`
}

// AsMap returns a map[string]interface{} that is required for create and update
func (object *UtilitiesNetworked) AsMap(isCreate bool) *map[string]interface{} {
	if isCreate {
		return &map[string]interface{}{
			"hostname": object.Hostname,
			"site":     object.Site,
		}
	}
	return &map[string]interface{}{
		"hostname": object.Hostname,
		"site":     object.Site,
	}
}

// UtilitiesNetworkedNew - Make a new object of Model Networked
func (service *Contractor) UtilitiesNetworkedNew() *UtilitiesNetworked {
	return &UtilitiesNetworked{cinp: service.cinp}
}

// UtilitiesNetworkedNewWithID - Make a new object of Model Networked
func (service *Contractor) UtilitiesNetworkedNewWithID(id int) *UtilitiesNetworked {
	result := UtilitiesNetworked{cinp: service.cinp}
	result.SetID("/api/v1/Utilities/Networked:" + strconv.FormatInt(int64(id), 10) + ":")
	return &result
}

// UtilitiesNetworkedGet - Get function for Model Networked
func (service *Contractor) UtilitiesNetworkedGet(id int) (*UtilitiesNetworked, error) {
	object, err := service.cinp.Get("/api/v1/Utilities/Networked:" + strconv.FormatInt(int64(id), 10) + ":")
	if err != nil {
		return nil, err
	}
	result := (*object).(*UtilitiesNetworked)
	result.cinp = service.cinp

	return result, nil
}

// Create - Create function for Model Networked
func (object *UtilitiesNetworked) Create() error {
	if err := object.cinp.Create("/api/v1/Utilities/Networked", object); err != nil {
		return err
	}

	return nil
}

// Update - Update function for Model Networked
func (object *UtilitiesNetworked) Update(fieldList []string) error {
	if err := object.cinp.Update(object, fieldList); err != nil {
		return err
	}

	return nil
}

// Delete - Delete function for Model Networked
func (object *UtilitiesNetworked) Delete() error {
	if err := object.cinp.Delete(object); err != nil {
		return err
	}

	return nil
}

// UtilitiesNetworkedListFilters - Return a slice of valid filter names Networked
func (service *Contractor) UtilitiesNetworkedListFilters() [0]string {
	return [0]string{}
}

// UtilitiesNetworkedList - List function for Model Networked
func (service *Contractor) UtilitiesNetworkedList(filterName string, filterValues map[string]interface{}) (<-chan *UtilitiesNetworked, error) {
	if filterName != "" {
		for _, item := range service.UtilitiesNetworkedListFilters() {
			if item == filterName {
				goto good
			}
		}
		return nil, fmt.Errorf("Filter '%s' is invalid", filterName)
	}
good:

	in := service.cinp.ListObjects("/api/v1/Utilities/Networked", reflect.TypeOf(UtilitiesNetworked{}), filterName, filterValues, 50)
	out := make(chan *UtilitiesNetworked)
	go func() {
		defer close(out)
		for v := range in {
			v.(*UtilitiesNetworked).cinp = service.cinp
			out <- v.(*UtilitiesNetworked)
		}
	}()
	return out, nil
}

// UtilitiesAddressBlock - Model AddressBlock(/api/v1/Utilities/AddressBlock)
/*
AddressBlock(id, name, site, subnet, prefix, gateway_offset, _max_address, updated, created)
*/
type UtilitiesAddressBlock struct {
	cinp.BaseObject
	cinp          *cinp.CInP
	Name          *string    `json:"name"`
	Site          *string    `json:"site"`
	Subnet        *string    `json:"subnet"`
	Prefix        *int       `json:"prefix"`
	GatewayOffset *int       `json:"gateway_offset"`
	MaxAddress    *string    `json:"_max_address"`
	Updated       *time.Time `json:"updated"`
	Created       *time.Time `json:"created"`
	ID            *int       `json:"id"`
	Gateway       *string    `json:"gateway"`
	Netmask       *string    `json:"netmask"`
	Size          *string    `json:"size"`
	Isipv4        *string    `json:"isIpV4"`
}

// AsMap returns a map[string]interface{} that is required for create and update
func (object *UtilitiesAddressBlock) AsMap(isCreate bool) *map[string]interface{} {
	if isCreate {
		return &map[string]interface{}{
			"name":           object.Name,
			"site":           object.Site,
			"subnet":         object.Subnet,
			"prefix":         object.Prefix,
			"gateway_offset": object.GatewayOffset,
		}
	}
	return &map[string]interface{}{
		"name":           object.Name,
		"site":           object.Site,
		"subnet":         object.Subnet,
		"prefix":         object.Prefix,
		"gateway_offset": object.GatewayOffset,
	}
}

// UtilitiesAddressBlockNew - Make a new object of Model AddressBlock
func (service *Contractor) UtilitiesAddressBlockNew() *UtilitiesAddressBlock {
	return &UtilitiesAddressBlock{cinp: service.cinp}
}

// UtilitiesAddressBlockNewWithID - Make a new object of Model AddressBlock
func (service *Contractor) UtilitiesAddressBlockNewWithID(id int) *UtilitiesAddressBlock {
	result := UtilitiesAddressBlock{cinp: service.cinp}
	result.SetID("/api/v1/Utilities/AddressBlock:" + strconv.FormatInt(int64(id), 10) + ":")
	return &result
}

// UtilitiesAddressBlockGet - Get function for Model AddressBlock
func (service *Contractor) UtilitiesAddressBlockGet(id int) (*UtilitiesAddressBlock, error) {
	object, err := service.cinp.Get("/api/v1/Utilities/AddressBlock:" + strconv.FormatInt(int64(id), 10) + ":")
	if err != nil {
		return nil, err
	}
	result := (*object).(*UtilitiesAddressBlock)
	result.cinp = service.cinp

	return result, nil
}

// Create - Create function for Model AddressBlock
func (object *UtilitiesAddressBlock) Create() error {
	if err := object.cinp.Create("/api/v1/Utilities/AddressBlock", object); err != nil {
		return err
	}

	return nil
}

// Update - Update function for Model AddressBlock
func (object *UtilitiesAddressBlock) Update(fieldList []string) error {
	if err := object.cinp.Update(object, fieldList); err != nil {
		return err
	}

	return nil
}

// Delete - Delete function for Model AddressBlock
func (object *UtilitiesAddressBlock) Delete() error {
	if err := object.cinp.Delete(object); err != nil {
		return err
	}

	return nil
}

// UtilitiesAddressBlockListFilters - Return a slice of valid filter names AddressBlock
func (service *Contractor) UtilitiesAddressBlockListFilters() [1]string {
	return [1]string{"site"}
}

// UtilitiesAddressBlockList - List function for Model AddressBlock
func (service *Contractor) UtilitiesAddressBlockList(filterName string, filterValues map[string]interface{}) (<-chan *UtilitiesAddressBlock, error) {
	if filterName != "" {
		for _, item := range service.UtilitiesAddressBlockListFilters() {
			if item == filterName {
				goto good
			}
		}
		return nil, fmt.Errorf("Filter '%s' is invalid", filterName)
	}
good:

	in := service.cinp.ListObjects("/api/v1/Utilities/AddressBlock", reflect.TypeOf(UtilitiesAddressBlock{}), filterName, filterValues, 50)
	out := make(chan *UtilitiesAddressBlock)
	go func() {
		defer close(out)
		for v := range in {
			v.(*UtilitiesAddressBlock).cinp = service.cinp
			out <- v.(*UtilitiesAddressBlock)
		}
	}()
	return out, nil
}

// CallNextAddress calls nextAddress
func (object *UtilitiesAddressBlock) CallNextAddress(Networked string, InterfaceName string, IsPrimary bool) (string, error) {
	args := map[string]interface{}{
		"networked":      Networked,
		"interface_name": InterfaceName,
		"is_primary":     IsPrimary,
	}
	_, _, _, ids, _, err := object.cinp.Split(object.GetID())
	if err != nil {
		return "", err
	}
	uri, err := object.cinp.UpdateIDs("/api/v1/Utilities/AddressBlock(nextAddress)", ids)
	if err != nil {
		return "", err
	}

	result := ""

	if err := object.cinp.Call(uri, &args, &result); err != nil {
		return "", err
	}

	return result, nil
}

// CallUsage calls usage
func (object *UtilitiesAddressBlock) CallUsage() (map[string]interface{}, error) {
	args := map[string]interface{}{}
	_, _, _, ids, _, err := object.cinp.Split(object.GetID())
	if err != nil {
		return nil, err
	}
	uri, err := object.cinp.UpdateIDs("/api/v1/Utilities/AddressBlock(usage)", ids)
	if err != nil {
		return nil, err
	}

	result := map[string]interface{}{}

	if err := object.cinp.Call(uri, &args, &result); err != nil {
		return nil, err
	}

	return result, nil
}

// UtilitiesAddressBlockCallGetWithNameSite calls getWithNameSite
func (service *Contractor) UtilitiesAddressBlockCallGetWithNameSite(Site string, Name string) (string, error) {
	args := map[string]interface{}{
		"site": Site,
		"name": Name,
	}
	uri := "/api/v1/Utilities/AddressBlock(getWithNameSite)"

	result := ""

	if err := service.cinp.Call(uri, &args, &result); err != nil {
		return "", err
	}

	return result, nil
}

// UtilitiesNetwork - Model Network(/api/v1/Utilities/Network)
/*
Network(id, name, site, mtu, updated, created)
*/
type UtilitiesNetwork struct {
	cinp.BaseObject
	cinp             *cinp.CInP
	Name             *string    `json:"name"`
	Site             *string    `json:"site"`
	Mtu              *int       `json:"mtu"`
	Updated          *time.Time `json:"updated"`
	Created          *time.Time `json:"created"`
	AddressBlockList *[]string  `json:"address_block_list"`
	ID               *int       `json:"id"`
}

// AsMap returns a map[string]interface{} that is required for create and update
func (object *UtilitiesNetwork) AsMap(isCreate bool) *map[string]interface{} {
	if isCreate {
		return &map[string]interface{}{
			"name":               object.Name,
			"site":               object.Site,
			"mtu":                object.Mtu,
			"address_block_list": object.AddressBlockList,
		}
	}
	return &map[string]interface{}{
		"name":               object.Name,
		"site":               object.Site,
		"mtu":                object.Mtu,
		"address_block_list": object.AddressBlockList,
	}
}

// UtilitiesNetworkNew - Make a new object of Model Network
func (service *Contractor) UtilitiesNetworkNew() *UtilitiesNetwork {
	return &UtilitiesNetwork{cinp: service.cinp}
}

// UtilitiesNetworkNewWithID - Make a new object of Model Network
func (service *Contractor) UtilitiesNetworkNewWithID(id int) *UtilitiesNetwork {
	result := UtilitiesNetwork{cinp: service.cinp}
	result.SetID("/api/v1/Utilities/Network:" + strconv.FormatInt(int64(id), 10) + ":")
	return &result
}

// UtilitiesNetworkGet - Get function for Model Network
func (service *Contractor) UtilitiesNetworkGet(id int) (*UtilitiesNetwork, error) {
	object, err := service.cinp.Get("/api/v1/Utilities/Network:" + strconv.FormatInt(int64(id), 10) + ":")
	if err != nil {
		return nil, err
	}
	result := (*object).(*UtilitiesNetwork)
	result.cinp = service.cinp

	return result, nil
}

// Create - Create function for Model Network
func (object *UtilitiesNetwork) Create() error {
	if err := object.cinp.Create("/api/v1/Utilities/Network", object); err != nil {
		return err
	}

	return nil
}

// Update - Update function for Model Network
func (object *UtilitiesNetwork) Update(fieldList []string) error {
	if err := object.cinp.Update(object, fieldList); err != nil {
		return err
	}

	return nil
}

// Delete - Delete function for Model Network
func (object *UtilitiesNetwork) Delete() error {
	if err := object.cinp.Delete(object); err != nil {
		return err
	}

	return nil
}

// UtilitiesNetworkListFilters - Return a slice of valid filter names Network
func (service *Contractor) UtilitiesNetworkListFilters() [1]string {
	return [1]string{"site"}
}

// UtilitiesNetworkList - List function for Model Network
func (service *Contractor) UtilitiesNetworkList(filterName string, filterValues map[string]interface{}) (<-chan *UtilitiesNetwork, error) {
	if filterName != "" {
		for _, item := range service.UtilitiesNetworkListFilters() {
			if item == filterName {
				goto good
			}
		}
		return nil, fmt.Errorf("Filter '%s' is invalid", filterName)
	}
good:

	in := service.cinp.ListObjects("/api/v1/Utilities/Network", reflect.TypeOf(UtilitiesNetwork{}), filterName, filterValues, 50)
	out := make(chan *UtilitiesNetwork)
	go func() {
		defer close(out)
		for v := range in {
			v.(*UtilitiesNetwork).cinp = service.cinp
			out <- v.(*UtilitiesNetwork)
		}
	}()
	return out, nil
}

// UtilitiesNetworkCallGetWithNameSite calls getWithNameSite
func (service *Contractor) UtilitiesNetworkCallGetWithNameSite(Site string, Name string) (string, error) {
	args := map[string]interface{}{
		"site": Site,
		"name": Name,
	}
	uri := "/api/v1/Utilities/Network(getWithNameSite)"

	result := ""

	if err := service.cinp.Call(uri, &args, &result); err != nil {
		return "", err
	}

	return result, nil
}

// UtilitiesNetworkAddressBlock - Model NetworkAddressBlock(/api/v1/Utilities/NetworkAddressBlock)
/*
NetworkAddressBlock(id, network, address_block, vlan, updated, created)
*/
type UtilitiesNetworkAddressBlock struct {
	cinp.BaseObject
	cinp         *cinp.CInP
	Network      *string    `json:"network"`
	AddressBlock *string    `json:"address_block"`
	Vlan         *int       `json:"vlan"`
	Updated      *time.Time `json:"updated"`
	Created      *time.Time `json:"created"`
	ID           *int       `json:"id"`
}

// AsMap returns a map[string]interface{} that is required for create and update
func (object *UtilitiesNetworkAddressBlock) AsMap(isCreate bool) *map[string]interface{} {
	if isCreate {
		return &map[string]interface{}{
			"network":       object.Network,
			"address_block": object.AddressBlock,
			"vlan":          object.Vlan,
		}
	}
	return &map[string]interface{}{
		"network":       object.Network,
		"address_block": object.AddressBlock,
		"vlan":          object.Vlan,
	}
}

// UtilitiesNetworkAddressBlockNew - Make a new object of Model NetworkAddressBlock
func (service *Contractor) UtilitiesNetworkAddressBlockNew() *UtilitiesNetworkAddressBlock {
	return &UtilitiesNetworkAddressBlock{cinp: service.cinp}
}

// UtilitiesNetworkAddressBlockNewWithID - Make a new object of Model NetworkAddressBlock
func (service *Contractor) UtilitiesNetworkAddressBlockNewWithID(id int) *UtilitiesNetworkAddressBlock {
	result := UtilitiesNetworkAddressBlock{cinp: service.cinp}
	result.SetID("/api/v1/Utilities/NetworkAddressBlock:" + strconv.FormatInt(int64(id), 10) + ":")
	return &result
}

// UtilitiesNetworkAddressBlockGet - Get function for Model NetworkAddressBlock
func (service *Contractor) UtilitiesNetworkAddressBlockGet(id int) (*UtilitiesNetworkAddressBlock, error) {
	object, err := service.cinp.Get("/api/v1/Utilities/NetworkAddressBlock:" + strconv.FormatInt(int64(id), 10) + ":")
	if err != nil {
		return nil, err
	}
	result := (*object).(*UtilitiesNetworkAddressBlock)
	result.cinp = service.cinp

	return result, nil
}

// Create - Create function for Model NetworkAddressBlock
func (object *UtilitiesNetworkAddressBlock) Create() error {
	if err := object.cinp.Create("/api/v1/Utilities/NetworkAddressBlock", object); err != nil {
		return err
	}

	return nil
}

// Update - Update function for Model NetworkAddressBlock
func (object *UtilitiesNetworkAddressBlock) Update(fieldList []string) error {
	if err := object.cinp.Update(object, fieldList); err != nil {
		return err
	}

	return nil
}

// Delete - Delete function for Model NetworkAddressBlock
func (object *UtilitiesNetworkAddressBlock) Delete() error {
	if err := object.cinp.Delete(object); err != nil {
		return err
	}

	return nil
}

// UtilitiesNetworkAddressBlockListFilters - Return a slice of valid filter names NetworkAddressBlock
func (service *Contractor) UtilitiesNetworkAddressBlockListFilters() [2]string {
	return [2]string{"network", "address_block"}
}

// UtilitiesNetworkAddressBlockList - List function for Model NetworkAddressBlock
func (service *Contractor) UtilitiesNetworkAddressBlockList(filterName string, filterValues map[string]interface{}) (<-chan *UtilitiesNetworkAddressBlock, error) {
	if filterName != "" {
		for _, item := range service.UtilitiesNetworkAddressBlockListFilters() {
			if item == filterName {
				goto good
			}
		}
		return nil, fmt.Errorf("Filter '%s' is invalid", filterName)
	}
good:

	in := service.cinp.ListObjects("/api/v1/Utilities/NetworkAddressBlock", reflect.TypeOf(UtilitiesNetworkAddressBlock{}), filterName, filterValues, 50)
	out := make(chan *UtilitiesNetworkAddressBlock)
	go func() {
		defer close(out)
		for v := range in {
			v.(*UtilitiesNetworkAddressBlock).cinp = service.cinp
			out <- v.(*UtilitiesNetworkAddressBlock)
		}
	}()
	return out, nil
}

// UtilitiesNetworkInterface - Model NetworkInterface(/api/v1/Utilities/NetworkInterface)
/*
NetworkInterface(id, name, network, updated, created)
*/
type UtilitiesNetworkInterface struct {
	cinp.BaseObject
	cinp    *cinp.CInP
	Name    *string    `json:"name"`
	Network *string    `json:"network"`
	Updated *time.Time `json:"updated"`
	Created *time.Time `json:"created"`
	ID      *int       `json:"id"`
	Type    *string    `json:"type"`
}

// AsMap returns a map[string]interface{} that is required for create and update
func (object *UtilitiesNetworkInterface) AsMap(isCreate bool) *map[string]interface{} {
	if isCreate {
		return &map[string]interface{}{
			"name":    object.Name,
			"network": object.Network,
		}
	}
	return &map[string]interface{}{
		"name":    object.Name,
		"network": object.Network,
	}
}

// UtilitiesNetworkInterfaceNew - Make a new object of Model NetworkInterface
func (service *Contractor) UtilitiesNetworkInterfaceNew() *UtilitiesNetworkInterface {
	return &UtilitiesNetworkInterface{cinp: service.cinp}
}

// UtilitiesNetworkInterfaceNewWithID - Make a new object of Model NetworkInterface
func (service *Contractor) UtilitiesNetworkInterfaceNewWithID(id int) *UtilitiesNetworkInterface {
	result := UtilitiesNetworkInterface{cinp: service.cinp}
	result.SetID("/api/v1/Utilities/NetworkInterface:" + strconv.FormatInt(int64(id), 10) + ":")
	return &result
}

// UtilitiesRealNetworkInterface - Model RealNetworkInterface(/api/v1/Utilities/RealNetworkInterface)
/*
RealNetworkInterface(id, name, network, updated, created, networkinterface_ptr, mac, foundation, is_provisioning, physical_location, link_name, pxe)
*/
type UtilitiesRealNetworkInterface struct {
	cinp.BaseObject
	cinp             *cinp.CInP
	Name             *string    `json:"name"`
	Network          *string    `json:"network"`
	Updated          *time.Time `json:"updated"`
	Created          *time.Time `json:"created"`
	Mac              *string    `json:"mac"`
	Foundation       *string    `json:"foundation"`
	IsProvisioning   *bool      `json:"is_provisioning"`
	PhysicalLocation *string    `json:"physical_location"`
	LinkName         *string    `json:"link_name"`
	Pxe              *string    `json:"pxe"`
	ID               *int       `json:"id"`
	Type             *string    `json:"type"`
}

// AsMap returns a map[string]interface{} that is required for create and update
func (object *UtilitiesRealNetworkInterface) AsMap(isCreate bool) *map[string]interface{} {
	if isCreate {
		return &map[string]interface{}{
			"name":              object.Name,
			"network":           object.Network,
			"mac":               object.Mac,
			"foundation":        object.Foundation,
			"is_provisioning":   object.IsProvisioning,
			"physical_location": object.PhysicalLocation,
			"link_name":         object.LinkName,
			"pxe":               object.Pxe,
		}
	}
	return &map[string]interface{}{
		"name":              object.Name,
		"network":           object.Network,
		"mac":               object.Mac,
		"foundation":        object.Foundation,
		"is_provisioning":   object.IsProvisioning,
		"physical_location": object.PhysicalLocation,
		"link_name":         object.LinkName,
		"pxe":               object.Pxe,
	}
}

// UtilitiesRealNetworkInterfaceNew - Make a new object of Model RealNetworkInterface
func (service *Contractor) UtilitiesRealNetworkInterfaceNew() *UtilitiesRealNetworkInterface {
	return &UtilitiesRealNetworkInterface{cinp: service.cinp}
}

// UtilitiesRealNetworkInterfaceNewWithID - Make a new object of Model RealNetworkInterface
func (service *Contractor) UtilitiesRealNetworkInterfaceNewWithID(id int) *UtilitiesRealNetworkInterface {
	result := UtilitiesRealNetworkInterface{cinp: service.cinp}
	result.SetID("/api/v1/Utilities/RealNetworkInterface:" + strconv.FormatInt(int64(id), 10) + ":")
	return &result
}

// UtilitiesRealNetworkInterfaceGet - Get function for Model RealNetworkInterface
func (service *Contractor) UtilitiesRealNetworkInterfaceGet(id int) (*UtilitiesRealNetworkInterface, error) {
	object, err := service.cinp.Get("/api/v1/Utilities/RealNetworkInterface:" + strconv.FormatInt(int64(id), 10) + ":")
	if err != nil {
		return nil, err
	}
	result := (*object).(*UtilitiesRealNetworkInterface)
	result.cinp = service.cinp

	return result, nil
}

// Create - Create function for Model RealNetworkInterface
func (object *UtilitiesRealNetworkInterface) Create() error {
	if err := object.cinp.Create("/api/v1/Utilities/RealNetworkInterface", object); err != nil {
		return err
	}

	return nil
}

// Update - Update function for Model RealNetworkInterface
func (object *UtilitiesRealNetworkInterface) Update(fieldList []string) error {
	if err := object.cinp.Update(object, fieldList); err != nil {
		return err
	}

	return nil
}

// Delete - Delete function for Model RealNetworkInterface
func (object *UtilitiesRealNetworkInterface) Delete() error {
	if err := object.cinp.Delete(object); err != nil {
		return err
	}

	return nil
}

// UtilitiesRealNetworkInterfaceListFilters - Return a slice of valid filter names RealNetworkInterface
func (service *Contractor) UtilitiesRealNetworkInterfaceListFilters() [1]string {
	return [1]string{"foundation"}
}

// UtilitiesRealNetworkInterfaceList - List function for Model RealNetworkInterface
func (service *Contractor) UtilitiesRealNetworkInterfaceList(filterName string, filterValues map[string]interface{}) (<-chan *UtilitiesRealNetworkInterface, error) {
	if filterName != "" {
		for _, item := range service.UtilitiesRealNetworkInterfaceListFilters() {
			if item == filterName {
				goto good
			}
		}
		return nil, fmt.Errorf("Filter '%s' is invalid", filterName)
	}
good:

	in := service.cinp.ListObjects("/api/v1/Utilities/RealNetworkInterface", reflect.TypeOf(UtilitiesRealNetworkInterface{}), filterName, filterValues, 50)
	out := make(chan *UtilitiesRealNetworkInterface)
	go func() {
		defer close(out)
		for v := range in {
			v.(*UtilitiesRealNetworkInterface).cinp = service.cinp
			out <- v.(*UtilitiesRealNetworkInterface)
		}
	}()
	return out, nil
}

// UtilitiesAbstractNetworkInterface - Model AbstractNetworkInterface(/api/v1/Utilities/AbstractNetworkInterface)
/*
AbstractNetworkInterface(id, name, network, updated, created, networkinterface_ptr, structure)
*/
type UtilitiesAbstractNetworkInterface struct {
	cinp.BaseObject
	cinp      *cinp.CInP
	Name      *string    `json:"name"`
	Network   *string    `json:"network"`
	Updated   *time.Time `json:"updated"`
	Created   *time.Time `json:"created"`
	Structure *string    `json:"structure"`
	ID        *int       `json:"id"`
	Type      *string    `json:"type"`
}

// AsMap returns a map[string]interface{} that is required for create and update
func (object *UtilitiesAbstractNetworkInterface) AsMap(isCreate bool) *map[string]interface{} {
	if isCreate {
		return &map[string]interface{}{
			"name":      object.Name,
			"network":   object.Network,
			"structure": object.Structure,
		}
	}
	return &map[string]interface{}{
		"name":      object.Name,
		"network":   object.Network,
		"structure": object.Structure,
	}
}

// UtilitiesAbstractNetworkInterfaceNew - Make a new object of Model AbstractNetworkInterface
func (service *Contractor) UtilitiesAbstractNetworkInterfaceNew() *UtilitiesAbstractNetworkInterface {
	return &UtilitiesAbstractNetworkInterface{cinp: service.cinp}
}

// UtilitiesAbstractNetworkInterfaceNewWithID - Make a new object of Model AbstractNetworkInterface
func (service *Contractor) UtilitiesAbstractNetworkInterfaceNewWithID(id int) *UtilitiesAbstractNetworkInterface {
	result := UtilitiesAbstractNetworkInterface{cinp: service.cinp}
	result.SetID("/api/v1/Utilities/AbstractNetworkInterface:" + strconv.FormatInt(int64(id), 10) + ":")
	return &result
}

// UtilitiesAbstractNetworkInterfaceGet - Get function for Model AbstractNetworkInterface
func (service *Contractor) UtilitiesAbstractNetworkInterfaceGet(id int) (*UtilitiesAbstractNetworkInterface, error) {
	object, err := service.cinp.Get("/api/v1/Utilities/AbstractNetworkInterface:" + strconv.FormatInt(int64(id), 10) + ":")
	if err != nil {
		return nil, err
	}
	result := (*object).(*UtilitiesAbstractNetworkInterface)
	result.cinp = service.cinp

	return result, nil
}

// Create - Create function for Model AbstractNetworkInterface
func (object *UtilitiesAbstractNetworkInterface) Create() error {
	if err := object.cinp.Create("/api/v1/Utilities/AbstractNetworkInterface", object); err != nil {
		return err
	}

	return nil
}

// Update - Update function for Model AbstractNetworkInterface
func (object *UtilitiesAbstractNetworkInterface) Update(fieldList []string) error {
	if err := object.cinp.Update(object, fieldList); err != nil {
		return err
	}

	return nil
}

// Delete - Delete function for Model AbstractNetworkInterface
func (object *UtilitiesAbstractNetworkInterface) Delete() error {
	if err := object.cinp.Delete(object); err != nil {
		return err
	}

	return nil
}

// UtilitiesAbstractNetworkInterfaceListFilters - Return a slice of valid filter names AbstractNetworkInterface
func (service *Contractor) UtilitiesAbstractNetworkInterfaceListFilters() [1]string {
	return [1]string{"structure"}
}

// UtilitiesAbstractNetworkInterfaceList - List function for Model AbstractNetworkInterface
func (service *Contractor) UtilitiesAbstractNetworkInterfaceList(filterName string, filterValues map[string]interface{}) (<-chan *UtilitiesAbstractNetworkInterface, error) {
	if filterName != "" {
		for _, item := range service.UtilitiesAbstractNetworkInterfaceListFilters() {
			if item == filterName {
				goto good
			}
		}
		return nil, fmt.Errorf("Filter '%s' is invalid", filterName)
	}
good:

	in := service.cinp.ListObjects("/api/v1/Utilities/AbstractNetworkInterface", reflect.TypeOf(UtilitiesAbstractNetworkInterface{}), filterName, filterValues, 50)
	out := make(chan *UtilitiesAbstractNetworkInterface)
	go func() {
		defer close(out)
		for v := range in {
			v.(*UtilitiesAbstractNetworkInterface).cinp = service.cinp
			out <- v.(*UtilitiesAbstractNetworkInterface)
		}
	}()
	return out, nil
}

// UtilitiesAggregatedNetworkInterface - Model AggregatedNetworkInterface(/api/v1/Utilities/AggregatedNetworkInterface)
/*
AggregatedNetworkInterface(id, name, network, updated, created, networkinterface_ptr, structure, abstractnetworkinterface_ptr, primary_interface, paramaters)
*/
type UtilitiesAggregatedNetworkInterface struct {
	cinp.BaseObject
	cinp                *cinp.CInP
	Name                *string                 `json:"name"`
	Network             *string                 `json:"network"`
	Updated             *time.Time              `json:"updated"`
	Created             *time.Time              `json:"created"`
	Structure           *string                 `json:"structure"`
	PrimaryInterface    *string                 `json:"primary_interface"`
	Paramaters          *map[string]interface{} `json:"paramaters"`
	SecondaryInterfaces *[]string               `json:"secondary_interfaces"`
	NetworkinterfacePtr *string                 `json:"networkinterface_ptr"`
	Type                *string                 `json:"type"`
}

// AsMap returns a map[string]interface{} that is required for create and update
func (object *UtilitiesAggregatedNetworkInterface) AsMap(isCreate bool) *map[string]interface{} {
	if isCreate {
		return &map[string]interface{}{
			"name":                 object.Name,
			"network":              object.Network,
			"structure":            object.Structure,
			"primary_interface":    object.PrimaryInterface,
			"paramaters":           object.Paramaters,
			"secondary_interfaces": object.SecondaryInterfaces,
		}
	}
	return &map[string]interface{}{
		"name":                 object.Name,
		"network":              object.Network,
		"structure":            object.Structure,
		"primary_interface":    object.PrimaryInterface,
		"paramaters":           object.Paramaters,
		"secondary_interfaces": object.SecondaryInterfaces,
	}
}

// UtilitiesAggregatedNetworkInterfaceNew - Make a new object of Model AggregatedNetworkInterface
func (service *Contractor) UtilitiesAggregatedNetworkInterfaceNew() *UtilitiesAggregatedNetworkInterface {
	return &UtilitiesAggregatedNetworkInterface{cinp: service.cinp}
}

// UtilitiesAggregatedNetworkInterfaceNewWithID - Make a new object of Model AggregatedNetworkInterface
func (service *Contractor) UtilitiesAggregatedNetworkInterfaceNewWithID(id string) *UtilitiesAggregatedNetworkInterface {
	result := UtilitiesAggregatedNetworkInterface{cinp: service.cinp}
	result.SetID("/api/v1/Utilities/AggregatedNetworkInterface:" + id + ":")
	return &result
}

// UtilitiesAggregatedNetworkInterfaceGet - Get function for Model AggregatedNetworkInterface
func (service *Contractor) UtilitiesAggregatedNetworkInterfaceGet(id string) (*UtilitiesAggregatedNetworkInterface, error) {
	object, err := service.cinp.Get("/api/v1/Utilities/AggregatedNetworkInterface:" + id + ":")
	if err != nil {
		return nil, err
	}
	result := (*object).(*UtilitiesAggregatedNetworkInterface)
	result.cinp = service.cinp

	return result, nil
}

// Create - Create function for Model AggregatedNetworkInterface
func (object *UtilitiesAggregatedNetworkInterface) Create() error {
	if err := object.cinp.Create("/api/v1/Utilities/AggregatedNetworkInterface", object); err != nil {
		return err
	}

	return nil
}

// Update - Update function for Model AggregatedNetworkInterface
func (object *UtilitiesAggregatedNetworkInterface) Update(fieldList []string) error {
	if err := object.cinp.Update(object, fieldList); err != nil {
		return err
	}

	return nil
}

// Delete - Delete function for Model AggregatedNetworkInterface
func (object *UtilitiesAggregatedNetworkInterface) Delete() error {
	if err := object.cinp.Delete(object); err != nil {
		return err
	}

	return nil
}

// UtilitiesAggregatedNetworkInterfaceListFilters - Return a slice of valid filter names AggregatedNetworkInterface
func (service *Contractor) UtilitiesAggregatedNetworkInterfaceListFilters() [1]string {
	return [1]string{"structure"}
}

// UtilitiesAggregatedNetworkInterfaceList - List function for Model AggregatedNetworkInterface
func (service *Contractor) UtilitiesAggregatedNetworkInterfaceList(filterName string, filterValues map[string]interface{}) (<-chan *UtilitiesAggregatedNetworkInterface, error) {
	if filterName != "" {
		for _, item := range service.UtilitiesAggregatedNetworkInterfaceListFilters() {
			if item == filterName {
				goto good
			}
		}
		return nil, fmt.Errorf("Filter '%s' is invalid", filterName)
	}
good:

	in := service.cinp.ListObjects("/api/v1/Utilities/AggregatedNetworkInterface", reflect.TypeOf(UtilitiesAggregatedNetworkInterface{}), filterName, filterValues, 50)
	out := make(chan *UtilitiesAggregatedNetworkInterface)
	go func() {
		defer close(out)
		for v := range in {
			v.(*UtilitiesAggregatedNetworkInterface).cinp = service.cinp
			out <- v.(*UtilitiesAggregatedNetworkInterface)
		}
	}()
	return out, nil
}

// UtilitiesBaseAddress - Model BaseAddress(/api/v1/Utilities/BaseAddress)
/*
BaseAddress(id, address_block, offset, updated, created)
*/
type UtilitiesBaseAddress struct {
	cinp.BaseObject
	cinp         *cinp.CInP
	AddressBlock *string    `json:"address_block"`
	Offset       *int       `json:"offset"`
	Updated      *time.Time `json:"updated"`
	Created      *time.Time `json:"created"`
	ID           *int       `json:"id"`
	Type         *string    `json:"type"`
	IPAddress    *string    `json:"ip_address"`
	Subnet       *string    `json:"subnet"`
	Netmask      *string    `json:"netmask"`
	Prefix       *string    `json:"prefix"`
	Gateway      *string    `json:"gateway"`
}

// AsMap returns a map[string]interface{} that is required for create and update
func (object *UtilitiesBaseAddress) AsMap(isCreate bool) *map[string]interface{} {
	if isCreate {
		return &map[string]interface{}{
			"address_block": object.AddressBlock,
			"offset":        object.Offset,
		}
	}
	return &map[string]interface{}{
		"address_block": object.AddressBlock,
		"offset":        object.Offset,
	}
}

// UtilitiesBaseAddressNew - Make a new object of Model BaseAddress
func (service *Contractor) UtilitiesBaseAddressNew() *UtilitiesBaseAddress {
	return &UtilitiesBaseAddress{cinp: service.cinp}
}

// UtilitiesBaseAddressNewWithID - Make a new object of Model BaseAddress
func (service *Contractor) UtilitiesBaseAddressNewWithID(id int) *UtilitiesBaseAddress {
	result := UtilitiesBaseAddress{cinp: service.cinp}
	result.SetID("/api/v1/Utilities/BaseAddress:" + strconv.FormatInt(int64(id), 10) + ":")
	return &result
}

// UtilitiesBaseAddressCallLookup calls lookup
func (service *Contractor) UtilitiesBaseAddressCallLookup(IPAddress string, Site string) (string, error) {
	args := map[string]interface{}{
		"ip_address": IPAddress,
		"site":       Site,
	}
	uri := "/api/v1/Utilities/BaseAddress(lookup)"

	result := ""

	if err := service.cinp.Call(uri, &args, &result); err != nil {
		return "", err
	}

	return result, nil
}

// UtilitiesAddress - Model Address(/api/v1/Utilities/Address)
/*
Address(id, address_block, offset, updated, created, baseaddress_ptr, networked, interface_name, alias_index, pointer, is_primary)
*/
type UtilitiesAddress struct {
	cinp.BaseObject
	cinp          *cinp.CInP
	AddressBlock  *string    `json:"address_block"`
	Offset        *int       `json:"offset"`
	Updated       *time.Time `json:"updated"`
	Created       *time.Time `json:"created"`
	Networked     *string    `json:"networked"`
	InterfaceName *string    `json:"interface_name"`
	AliasIndex    *int       `json:"alias_index"`
	Pointer       *string    `json:"pointer"`
	IsPrimary     *bool      `json:"is_primary"`
	ID            *int       `json:"id"`
	Type          *string    `json:"type"`
	IPAddress     *string    `json:"ip_address"`
	Subnet        *string    `json:"subnet"`
	Netmask       *string    `json:"netmask"`
	Prefix        *string    `json:"prefix"`
	Gateway       *string    `json:"gateway"`
}

// AsMap returns a map[string]interface{} that is required for create and update
func (object *UtilitiesAddress) AsMap(isCreate bool) *map[string]interface{} {
	if isCreate {
		return &map[string]interface{}{
			"address_block":  object.AddressBlock,
			"offset":         object.Offset,
			"networked":      object.Networked,
			"interface_name": object.InterfaceName,
			"alias_index":    object.AliasIndex,
			"pointer":        object.Pointer,
			"is_primary":     object.IsPrimary,
		}
	}
	return &map[string]interface{}{
		"address_block":  object.AddressBlock,
		"offset":         object.Offset,
		"networked":      object.Networked,
		"interface_name": object.InterfaceName,
		"alias_index":    object.AliasIndex,
		"pointer":        object.Pointer,
		"is_primary":     object.IsPrimary,
	}
}

// UtilitiesAddressNew - Make a new object of Model Address
func (service *Contractor) UtilitiesAddressNew() *UtilitiesAddress {
	return &UtilitiesAddress{cinp: service.cinp}
}

// UtilitiesAddressNewWithID - Make a new object of Model Address
func (service *Contractor) UtilitiesAddressNewWithID(id int) *UtilitiesAddress {
	result := UtilitiesAddress{cinp: service.cinp}
	result.SetID("/api/v1/Utilities/Address:" + strconv.FormatInt(int64(id), 10) + ":")
	return &result
}

// UtilitiesAddressGet - Get function for Model Address
func (service *Contractor) UtilitiesAddressGet(id int) (*UtilitiesAddress, error) {
	object, err := service.cinp.Get("/api/v1/Utilities/Address:" + strconv.FormatInt(int64(id), 10) + ":")
	if err != nil {
		return nil, err
	}
	result := (*object).(*UtilitiesAddress)
	result.cinp = service.cinp

	return result, nil
}

// Create - Create function for Model Address
func (object *UtilitiesAddress) Create() error {
	if err := object.cinp.Create("/api/v1/Utilities/Address", object); err != nil {
		return err
	}

	return nil
}

// Update - Update function for Model Address
func (object *UtilitiesAddress) Update(fieldList []string) error {
	if err := object.cinp.Update(object, fieldList); err != nil {
		return err
	}

	return nil
}

// Delete - Delete function for Model Address
func (object *UtilitiesAddress) Delete() error {
	if err := object.cinp.Delete(object); err != nil {
		return err
	}

	return nil
}

// UtilitiesAddressListFilters - Return a slice of valid filter names Address
func (service *Contractor) UtilitiesAddressListFilters() [2]string {
	return [2]string{"address_block", "structure"}
}

// UtilitiesAddressList - List function for Model Address
func (service *Contractor) UtilitiesAddressList(filterName string, filterValues map[string]interface{}) (<-chan *UtilitiesAddress, error) {
	if filterName != "" {
		for _, item := range service.UtilitiesAddressListFilters() {
			if item == filterName {
				goto good
			}
		}
		return nil, fmt.Errorf("Filter '%s' is invalid", filterName)
	}
good:

	in := service.cinp.ListObjects("/api/v1/Utilities/Address", reflect.TypeOf(UtilitiesAddress{}), filterName, filterValues, 50)
	out := make(chan *UtilitiesAddress)
	go func() {
		defer close(out)
		for v := range in {
			v.(*UtilitiesAddress).cinp = service.cinp
			out <- v.(*UtilitiesAddress)
		}
	}()
	return out, nil
}

// UtilitiesReservedAddress - Model ReservedAddress(/api/v1/Utilities/ReservedAddress)
/*
ReservedAddress(id, address_block, offset, updated, created, baseaddress_ptr, reason)
*/
type UtilitiesReservedAddress struct {
	cinp.BaseObject
	cinp         *cinp.CInP
	AddressBlock *string    `json:"address_block"`
	Offset       *int       `json:"offset"`
	Updated      *time.Time `json:"updated"`
	Created      *time.Time `json:"created"`
	Reason       *string    `json:"reason"`
	ID           *int       `json:"id"`
	Type         *string    `json:"type"`
	IPAddress    *string    `json:"ip_address"`
	Subnet       *string    `json:"subnet"`
	Netmask      *string    `json:"netmask"`
	Prefix       *string    `json:"prefix"`
	Gateway      *string    `json:"gateway"`
}

// AsMap returns a map[string]interface{} that is required for create and update
func (object *UtilitiesReservedAddress) AsMap(isCreate bool) *map[string]interface{} {
	if isCreate {
		return &map[string]interface{}{
			"address_block": object.AddressBlock,
			"offset":        object.Offset,
			"reason":        object.Reason,
		}
	}
	return &map[string]interface{}{
		"address_block": object.AddressBlock,
		"offset":        object.Offset,
		"reason":        object.Reason,
	}
}

// UtilitiesReservedAddressNew - Make a new object of Model ReservedAddress
func (service *Contractor) UtilitiesReservedAddressNew() *UtilitiesReservedAddress {
	return &UtilitiesReservedAddress{cinp: service.cinp}
}

// UtilitiesReservedAddressNewWithID - Make a new object of Model ReservedAddress
func (service *Contractor) UtilitiesReservedAddressNewWithID(id int) *UtilitiesReservedAddress {
	result := UtilitiesReservedAddress{cinp: service.cinp}
	result.SetID("/api/v1/Utilities/ReservedAddress:" + strconv.FormatInt(int64(id), 10) + ":")
	return &result
}

// UtilitiesReservedAddressGet - Get function for Model ReservedAddress
func (service *Contractor) UtilitiesReservedAddressGet(id int) (*UtilitiesReservedAddress, error) {
	object, err := service.cinp.Get("/api/v1/Utilities/ReservedAddress:" + strconv.FormatInt(int64(id), 10) + ":")
	if err != nil {
		return nil, err
	}
	result := (*object).(*UtilitiesReservedAddress)
	result.cinp = service.cinp

	return result, nil
}

// Create - Create function for Model ReservedAddress
func (object *UtilitiesReservedAddress) Create() error {
	if err := object.cinp.Create("/api/v1/Utilities/ReservedAddress", object); err != nil {
		return err
	}

	return nil
}

// Update - Update function for Model ReservedAddress
func (object *UtilitiesReservedAddress) Update(fieldList []string) error {
	if err := object.cinp.Update(object, fieldList); err != nil {
		return err
	}

	return nil
}

// Delete - Delete function for Model ReservedAddress
func (object *UtilitiesReservedAddress) Delete() error {
	if err := object.cinp.Delete(object); err != nil {
		return err
	}

	return nil
}

// UtilitiesReservedAddressListFilters - Return a slice of valid filter names ReservedAddress
func (service *Contractor) UtilitiesReservedAddressListFilters() [1]string {
	return [1]string{"address_block"}
}

// UtilitiesReservedAddressList - List function for Model ReservedAddress
func (service *Contractor) UtilitiesReservedAddressList(filterName string, filterValues map[string]interface{}) (<-chan *UtilitiesReservedAddress, error) {
	if filterName != "" {
		for _, item := range service.UtilitiesReservedAddressListFilters() {
			if item == filterName {
				goto good
			}
		}
		return nil, fmt.Errorf("Filter '%s' is invalid", filterName)
	}
good:

	in := service.cinp.ListObjects("/api/v1/Utilities/ReservedAddress", reflect.TypeOf(UtilitiesReservedAddress{}), filterName, filterValues, 50)
	out := make(chan *UtilitiesReservedAddress)
	go func() {
		defer close(out)
		for v := range in {
			v.(*UtilitiesReservedAddress).cinp = service.cinp
			out <- v.(*UtilitiesReservedAddress)
		}
	}()
	return out, nil
}

// UtilitiesDynamicAddress - Model DynamicAddress(/api/v1/Utilities/DynamicAddress)
/*
DynamicAddress(id, address_block, offset, updated, created, baseaddress_ptr, pxe)
*/
type UtilitiesDynamicAddress struct {
	cinp.BaseObject
	cinp         *cinp.CInP
	AddressBlock *string    `json:"address_block"`
	Offset       *int       `json:"offset"`
	Updated      *time.Time `json:"updated"`
	Created      *time.Time `json:"created"`
	Pxe          *string    `json:"pxe"`
	ID           *int       `json:"id"`
	Type         *string    `json:"type"`
	IPAddress    *string    `json:"ip_address"`
	Subnet       *string    `json:"subnet"`
	Netmask      *string    `json:"netmask"`
	Prefix       *string    `json:"prefix"`
	Gateway      *string    `json:"gateway"`
}

// AsMap returns a map[string]interface{} that is required for create and update
func (object *UtilitiesDynamicAddress) AsMap(isCreate bool) *map[string]interface{} {
	if isCreate {
		return &map[string]interface{}{
			"address_block": object.AddressBlock,
			"offset":        object.Offset,
			"pxe":           object.Pxe,
		}
	}
	return &map[string]interface{}{
		"address_block": object.AddressBlock,
		"offset":        object.Offset,
		"pxe":           object.Pxe,
	}
}

// UtilitiesDynamicAddressNew - Make a new object of Model DynamicAddress
func (service *Contractor) UtilitiesDynamicAddressNew() *UtilitiesDynamicAddress {
	return &UtilitiesDynamicAddress{cinp: service.cinp}
}

// UtilitiesDynamicAddressNewWithID - Make a new object of Model DynamicAddress
func (service *Contractor) UtilitiesDynamicAddressNewWithID(id int) *UtilitiesDynamicAddress {
	result := UtilitiesDynamicAddress{cinp: service.cinp}
	result.SetID("/api/v1/Utilities/DynamicAddress:" + strconv.FormatInt(int64(id), 10) + ":")
	return &result
}

// UtilitiesDynamicAddressGet - Get function for Model DynamicAddress
func (service *Contractor) UtilitiesDynamicAddressGet(id int) (*UtilitiesDynamicAddress, error) {
	object, err := service.cinp.Get("/api/v1/Utilities/DynamicAddress:" + strconv.FormatInt(int64(id), 10) + ":")
	if err != nil {
		return nil, err
	}
	result := (*object).(*UtilitiesDynamicAddress)
	result.cinp = service.cinp

	return result, nil
}

// Create - Create function for Model DynamicAddress
func (object *UtilitiesDynamicAddress) Create() error {
	if err := object.cinp.Create("/api/v1/Utilities/DynamicAddress", object); err != nil {
		return err
	}

	return nil
}

// Update - Update function for Model DynamicAddress
func (object *UtilitiesDynamicAddress) Update(fieldList []string) error {
	if err := object.cinp.Update(object, fieldList); err != nil {
		return err
	}

	return nil
}

// Delete - Delete function for Model DynamicAddress
func (object *UtilitiesDynamicAddress) Delete() error {
	if err := object.cinp.Delete(object); err != nil {
		return err
	}

	return nil
}

// UtilitiesDynamicAddressListFilters - Return a slice of valid filter names DynamicAddress
func (service *Contractor) UtilitiesDynamicAddressListFilters() [1]string {
	return [1]string{"address_block"}
}

// UtilitiesDynamicAddressList - List function for Model DynamicAddress
func (service *Contractor) UtilitiesDynamicAddressList(filterName string, filterValues map[string]interface{}) (<-chan *UtilitiesDynamicAddress, error) {
	if filterName != "" {
		for _, item := range service.UtilitiesDynamicAddressListFilters() {
			if item == filterName {
				goto good
			}
		}
		return nil, fmt.Errorf("Filter '%s' is invalid", filterName)
	}
good:

	in := service.cinp.ListObjects("/api/v1/Utilities/DynamicAddress", reflect.TypeOf(UtilitiesDynamicAddress{}), filterName, filterValues, 50)
	out := make(chan *UtilitiesDynamicAddress)
	go func() {
		defer close(out)
		for v := range in {
			v.(*UtilitiesDynamicAddress).cinp = service.cinp
			out <- v.(*UtilitiesDynamicAddress)
		}
	}()
	return out, nil
}

func registerUtilities(cinp *cinp.CInP) {
	cinp.RegisterType("/api/v1/Utilities/Networked", reflect.TypeOf((*UtilitiesNetworked)(nil)).Elem())
	cinp.RegisterType("/api/v1/Utilities/AddressBlock", reflect.TypeOf((*UtilitiesAddressBlock)(nil)).Elem())
	cinp.RegisterType("/api/v1/Utilities/Network", reflect.TypeOf((*UtilitiesNetwork)(nil)).Elem())
	cinp.RegisterType("/api/v1/Utilities/NetworkAddressBlock", reflect.TypeOf((*UtilitiesNetworkAddressBlock)(nil)).Elem())
	cinp.RegisterType("/api/v1/Utilities/NetworkInterface", reflect.TypeOf((*UtilitiesNetworkInterface)(nil)).Elem())
	cinp.RegisterType("/api/v1/Utilities/RealNetworkInterface", reflect.TypeOf((*UtilitiesRealNetworkInterface)(nil)).Elem())
	cinp.RegisterType("/api/v1/Utilities/AbstractNetworkInterface", reflect.TypeOf((*UtilitiesAbstractNetworkInterface)(nil)).Elem())
	cinp.RegisterType("/api/v1/Utilities/AggregatedNetworkInterface", reflect.TypeOf((*UtilitiesAggregatedNetworkInterface)(nil)).Elem())
	cinp.RegisterType("/api/v1/Utilities/BaseAddress", reflect.TypeOf((*UtilitiesBaseAddress)(nil)).Elem())
	cinp.RegisterType("/api/v1/Utilities/Address", reflect.TypeOf((*UtilitiesAddress)(nil)).Elem())
	cinp.RegisterType("/api/v1/Utilities/ReservedAddress", reflect.TypeOf((*UtilitiesReservedAddress)(nil)).Elem())
	cinp.RegisterType("/api/v1/Utilities/DynamicAddress", reflect.TypeOf((*UtilitiesDynamicAddress)(nil)).Elem())
}
